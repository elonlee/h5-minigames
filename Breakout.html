<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Breakout - Classic Arcade</title>
    <style>
        :root {
            --bg-1: #06070d;
            --bg-2: #11162a;
            --panel: #101526;
            --panel-border: #28314e;
            --text: #e8edff;
            --muted: #a8b1d9;
            --accent: #63e6ff;
            --danger: #ff6b6b;
            --good: #69db7c;
        }

        * { box-sizing: border-box; }

        body {
            margin: 0;
            min-height: 100vh;
            background: radial-gradient(circle at 15% 20%, #1d2a52 0%, var(--bg-1) 45%), var(--bg-1);
            color: var(--text);
            font-family: Arial, sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 12px;
        }

        #game-shell {
            width: 940px;
            max-width: 100%;
            background: linear-gradient(160deg, rgba(31, 40, 70, 0.7), rgba(9, 13, 25, 0.95));
            border: 1px solid var(--panel-border);
            box-shadow: 0 18px 60px rgba(0, 0, 0, 0.45);
            padding: 14px;
        }

        #hud {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-bottom: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }

        .hud-item {
            background: rgba(16, 21, 38, 0.9);
            border: 1px solid #2f3a61;
            padding: 8px;
            text-align: center;
        }

        .label { color: var(--muted); display: block; font-size: 12px; }
        .value { color: var(--text); font-weight: bold; font-size: 18px; }
        .value.combo { color: #ffd43b; }

        #status {
            margin: 8px 0;
            color: var(--muted);
            min-height: 18px;
            font-size: 13px;
        }

        #game-canvas {
            width: 100%;
            aspect-ratio: 5 / 3;
            background: #070a15;
            border: 1px solid #2e3757;
            display: block;
        }

        #actions {
            margin-top: 10px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        button {
            background: #18213b;
            color: var(--text);
            border: 1px solid #384671;
            padding: 8px 12px;
            min-height: 40px;
            cursor: pointer;
            font-size: 14px;
        }

        button:focus-visible {
            outline: 2px solid #77b6ff;
            outline-offset: 2px;
        }

        #mobile-controls {
            margin-top: 10px;
            display: none;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        #mobile-controls button {
            min-height: 48px;
            font-size: 18px;
            font-weight: bold;
        }

        @media (max-width: 900px) {
            #hud { grid-template-columns: repeat(3, 1fr); }
            #mobile-controls { display: grid; }
        }
    </style>
</head>
<body>
    <div id="game-shell">
        <div id="hud">
            <div class="hud-item"><span class="label">SCORE</span><span class="value" id="score">0</span></div>
            <div class="hud-item"><span class="label">HIGH</span><span class="value" id="high-score">0</span></div>
            <div class="hud-item"><span class="label">LIVES</span><span class="value" id="lives">3</span></div>
            <div class="hud-item"><span class="label">LEVEL</span><span class="value" id="level">1</span></div>
            <div class="hud-item"><span class="label">COMBO</span><span class="value combo" id="combo">x1</span></div>
        </div>
        <div id="status">按空格发球，左右方向键移动挡板</div>
        <canvas id="game-canvas" width="900" height="540" aria-label="Breakout 游戏画布"></canvas>
        <div id="actions">
            <button id="launch-btn" type="button">发球 (Space)</button>
            <button id="pause-btn" type="button">暂停 (P)</button>
            <button id="restart-btn" type="button">重开 (R)</button>
            <button id="sound-btn" type="button">声音: 开</button>
        </div>
        <div id="mobile-controls" aria-label="移动端控制">
            <button id="left-btn" type="button" aria-label="左移">◀</button>
            <button id="launch-mobile-btn" type="button" aria-label="发球">●</button>
            <button id="right-btn" type="button" aria-label="右移">▶</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');

        const scoreEl = document.getElementById('score');
        const highScoreEl = document.getElementById('high-score');
        const livesEl = document.getElementById('lives');
        const levelEl = document.getElementById('level');
        const comboEl = document.getElementById('combo');
        const statusEl = document.getElementById('status');

        const launchBtn = document.getElementById('launch-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const restartBtn = document.getElementById('restart-btn');
        const soundBtn = document.getElementById('sound-btn');

        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;
        const HIGH_SCORE_KEY = 'breakoutHighScore';

        const BRICK_COLS = 12;
        const BRICK_ROWS_BASE = 6;
        const BRICK_W = 62;
        const BRICK_H = 22;
        const BRICK_GAP = 8;
        const BRICK_TOP = 72;
        const BRICK_LEFT = (WIDTH - (BRICK_COLS * BRICK_W + (BRICK_COLS - 1) * BRICK_GAP)) / 2;

        const BRICK_PALETTE = ['#ff6b6b', '#ffa94d', '#ffd43b', '#69db7c', '#74c0fc', '#b197fc', '#f783ac'];

        const state = {
            running: false,
            paused: false,
            gameOver: false,
            win: false,
            level: 1,
            score: 0,
            lives: 3,
            combo: 1,
            comboTimer: 0,
            highScore: Number(localStorage.getItem(HIGH_SCORE_KEY) || 0),
            paddle: {
                x: WIDTH / 2 - 70,
                y: HEIGHT - 42,
                w: 140,
                h: 14,
                speed: 680,
                dx: 0
            },
            ball: {
                x: WIDTH / 2,
                y: HEIGHT - 56,
                r: 8,
                vx: 0,
                vy: 0,
                speed: 380,
                launched: false,
                trail: []
            },
            bricks: [],
            particles: [],
            shake: { time: 0, strength: 0 },
            flash: { time: 0, color: '#ffffff' },
            stars: Array.from({ length: 70 }, () => ({
                x: Math.random() * WIDTH,
                y: Math.random() * HEIGHT,
                s: Math.random() * 1.8 + 0.2,
                v: Math.random() * 20 + 8
            }))
        };

        const keys = { left: false, right: false };
        let mobileLeft = false;
        let mobileRight = false;
        const audio = {
            enabled: true,
            initialized: false,
            ctx: null,
            master: null,
            sfx: null,
            music: null,
            musicTimer: null,
            beat: 0
        };

        function initAudio() {
            if (audio.initialized) return;
            const Ctx = window.AudioContext || window.webkitAudioContext;
            if (!Ctx) {
                audio.enabled = false;
                soundBtn.textContent = '声音: 不支持';
                soundBtn.disabled = true;
                return;
            }
            audio.ctx = new Ctx();
            audio.master = audio.ctx.createGain();
            audio.sfx = audio.ctx.createGain();
            audio.music = audio.ctx.createGain();
            audio.master.gain.value = 0.7;
            audio.sfx.gain.value = 0.9;
            audio.music.gain.value = 0.62;
            audio.sfx.connect(audio.master);
            audio.music.connect(audio.master);
            audio.master.connect(audio.ctx.destination);
            audio.initialized = true;
        }

        function beep(freq, duration, type = 'square', volume = 0.08, offset = 0, retried = false) {
            if (!audio.enabled) return;
            initAudio();
            if (!audio.ctx) return;
            if (audio.ctx.state !== 'running') {
                if (retried) return;
                audio.ctx.resume().then(() => {
                    beep(freq, duration, type, volume, offset, true);
                }).catch(() => {});
                return;
            }
            const start = audio.ctx.currentTime + offset;
            const osc = audio.ctx.createOscillator();
            const gain = audio.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, start);
            gain.gain.setValueAtTime(0.0001, start);
            gain.gain.exponentialRampToValueAtTime(volume, start + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.0001, start + duration);
            osc.connect(gain);
            gain.connect(audio.sfx);
            osc.start(start);
            osc.stop(start + duration + 0.02);
        }

        function musicTone(freq, duration, type = 'triangle', volume = 0.045, offset = 0, retried = false) {
            if (!audio.enabled) return;
            initAudio();
            if (!audio.ctx) return;
            if (audio.ctx.state !== 'running') {
                if (retried) return;
                audio.ctx.resume().then(() => {
                    musicTone(freq, duration, type, volume, offset, true);
                }).catch(() => {});
                return;
            }
            const start = audio.ctx.currentTime + offset;
            const osc = audio.ctx.createOscillator();
            const gain = audio.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, start);
            gain.gain.setValueAtTime(0.0001, start);
            gain.gain.exponentialRampToValueAtTime(volume, start + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.0001, start + duration);
            osc.connect(gain);
            gain.connect(audio.music);
            osc.start(start);
            osc.stop(start + duration + 0.03);
        }

        async function unlockAudio() {
            initAudio();
            if (!audio.ctx) return;
            if (audio.ctx.state === 'suspended') {
                try {
                    await audio.ctx.resume();
                } catch (_) {}
            }
            if (audio.enabled && !audio.musicTimer) {
                startMusic();
            }
        }

        function startMusic() {
            if (!audio.enabled || audio.musicTimer) return;
            const melody = [392, 440, 494, 523, 494, 440, 392, 330];
            const bass = [131, 147, 165, 175, 165, 147, 131, 110];
            audio.beat = 0;
            audio.musicTimer = setInterval(() => {
                if (!audio.enabled || !audio.ctx || audio.ctx.state !== 'running') return;
                if (!state.running || state.paused || state.gameOver || state.win) return;
                const n = melody[audio.beat % melody.length];
                musicTone(n, 0.16, 'triangle', 0.06);
                musicTone(bass[audio.beat % bass.length], 0.2, 'sine', 0.05);
                audio.beat += 1;
            }, 190);
        }

        function stopMusic() {
            if (audio.musicTimer) {
                clearInterval(audio.musicTimer);
                audio.musicTimer = null;
            }
        }

        function setSoundEnabled(enabled) {
            audio.enabled = enabled;
            soundBtn.textContent = `声音: ${enabled ? '开' : '关'}`;
            if (!enabled) {
                stopMusic();
                return;
            }
            unlockAudio();
            startMusic();
        }

        function sfxLaunch() {
            beep(620, 0.06, 'triangle', 0.07);
            beep(860, 0.08, 'triangle', 0.05, 0.04);
        }

        function sfxPaddle() {
            beep(300, 0.04, 'square', 0.06);
            beep(420, 0.05, 'square', 0.05, 0.02);
        }

        function sfxWall() {
            beep(220, 0.03, 'square', 0.04);
        }

        function sfxBrickHit() {
            beep(460, 0.035, 'sawtooth', 0.05);
        }

        function sfxBrickBreak() {
            beep(520, 0.05, 'square', 0.06);
            beep(760, 0.07, 'triangle', 0.04, 0.02);
        }

        function sfxLoseLife() {
            beep(260, 0.08, 'sine', 0.07);
            beep(180, 0.13, 'sine', 0.06, 0.08);
        }

        function sfxGameOver() {
            beep(320, 0.12, 'square', 0.08);
            beep(220, 0.18, 'square', 0.07, 0.1);
            beep(160, 0.22, 'square', 0.06, 0.22);
        }

        function sfxWin() {
            beep(523, 0.08, 'triangle', 0.07);
            beep(659, 0.1, 'triangle', 0.07, 0.08);
            beep(784, 0.16, 'triangle', 0.06, 0.18);
        }

        function clamp(v, min, max) {
            return Math.max(min, Math.min(max, v));
        }

        function setStatus(text) {
            statusEl.textContent = text;
        }

        function resetBall() {
            const ball = state.ball;
            ball.launched = false;
            ball.vx = 0;
            ball.vy = 0;
            ball.x = state.paddle.x + state.paddle.w / 2;
            ball.y = state.paddle.y - ball.r - 2;
            ball.trail = [];
        }

        function createBricks(level) {
            const rows = BRICK_ROWS_BASE + Math.min(3, level - 1);
            const bricks = [];
            for (let r = 0; r < rows; r += 1) {
                for (let c = 0; c < BRICK_COLS; c += 1) {
                    const hp = 1 + ((r + level) % 2);
                    bricks.push({
                        x: BRICK_LEFT + c * (BRICK_W + BRICK_GAP),
                        y: BRICK_TOP + r * (BRICK_H + BRICK_GAP),
                        w: BRICK_W,
                        h: BRICK_H,
                        hp,
                        maxHp: hp,
                        alive: true,
                        color: BRICK_PALETTE[r % BRICK_PALETTE.length]
                    });
                }
            }
            state.bricks = bricks;
        }

        function resetLevel(level = 1, preserveScore = false) {
            state.level = level;
            if (!preserveScore) {
                state.score = 0;
                state.lives = 3;
            }
            state.combo = 1;
            state.comboTimer = 0;
            state.running = true;
            state.paused = false;
            state.gameOver = false;
            state.win = false;
            state.paddle.x = WIDTH / 2 - state.paddle.w / 2;
            createBricks(state.level);
            resetBall();
            updateHud();
        }

        function launchBall() {
            unlockAudio();
            if (state.gameOver || state.win || state.paused) return;
            if (!state.ball.launched) {
                const angle = -Math.PI / 2 + (Math.random() * 0.65 - 0.325);
                state.ball.vx = Math.cos(angle) * state.ball.speed;
                state.ball.vy = Math.sin(angle) * state.ball.speed;
                state.ball.launched = true;
                setStatus('进行中：打碎全部砖块！');
                sfxLaunch();
            }
        }

        function updateHud() {
            scoreEl.textContent = String(state.score);
            highScoreEl.textContent = String(state.highScore);
            livesEl.textContent = String(state.lives);
            levelEl.textContent = String(state.level);
            comboEl.textContent = `x${state.combo}`;
        }

        function addScore(base) {
            state.score += base * state.combo;
            if (state.score > state.highScore) {
                state.highScore = state.score;
                localStorage.setItem(HIGH_SCORE_KEY, String(state.highScore));
            }
        }

        function triggerShake(strength, duration) {
            state.shake.time = Math.max(state.shake.time, duration);
            state.shake.strength = Math.max(state.shake.strength, strength);
        }

        function triggerFlash(color, duration) {
            state.flash.color = color;
            state.flash.time = Math.max(state.flash.time, duration);
        }

        function spawnBrickParticles(brick, impactX, impactY) {
            for (let i = 0; i < 16; i += 1) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 180 + 90;
                state.particles.push({
                    x: impactX,
                    y: impactY,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 0.45 + Math.random() * 0.25,
                    maxLife: 0.45 + Math.random() * 0.25,
                    size: Math.random() * 3 + 2,
                    color: brick.color
                });
            }
        }

        function loseLife() {
            state.lives -= 1;
            state.combo = 1;
            state.comboTimer = 0;
            triggerFlash('#ff6b6b', 0.35);
            triggerShake(12, 0.25);
            if (state.lives <= 0) {
                state.running = false;
                state.gameOver = true;
                setStatus('游戏结束：按 R 重开');
                stopMusic();
                sfxGameOver();
                return;
            }
            resetBall();
            setStatus('掉球了，按空格继续');
            sfxLoseLife();
        }

        function handleBrickHit(brick, ball) {
            brick.hp -= 1;
            const cx = clamp(ball.x, brick.x, brick.x + brick.w);
            const cy = clamp(ball.y, brick.y, brick.y + brick.h);
            spawnBrickParticles(brick, cx, cy);
            triggerShake(6, 0.12);

            if (brick.hp <= 0) {
                brick.alive = false;
                state.combo = Math.min(8, state.combo + 1);
                state.comboTimer = 2.2;
                addScore(12 + state.level * 2);
                triggerFlash('#63e6ff', 0.08);
                sfxBrickBreak();
            } else {
                addScore(4);
                triggerFlash('#ffd43b', 0.06);
                sfxBrickHit();
            }

            if (state.bricks.every((b) => !b.alive)) {
                state.level += 1;
                if (state.level > 6) {
                    state.running = false;
                    state.win = true;
                    setStatus('通关！按 R 再来一局');
                    stopMusic();
                    sfxWin();
                } else {
                    createBricks(state.level);
                    resetBall();
                    setStatus(`第 ${state.level} 关，按空格发球`);
                    beep(700, 0.08, 'triangle', 0.06);
                }
            }
        }

        function updateBall(dt) {
            const ball = state.ball;
            if (!ball.launched) {
                ball.x = state.paddle.x + state.paddle.w / 2;
                ball.y = state.paddle.y - ball.r - 2;
                return;
            }

            const steps = Math.max(1, Math.ceil((Math.abs(ball.vx) + Math.abs(ball.vy)) * dt / 32));
            const stepDt = dt / steps;

            for (let i = 0; i < steps; i += 1) {
                ball.x += ball.vx * stepDt;
                ball.y += ball.vy * stepDt;

                if (ball.x <= ball.r) {
                    ball.x = ball.r;
                    ball.vx = Math.abs(ball.vx);
                    triggerShake(3, 0.06);
                    sfxWall();
                } else if (ball.x >= WIDTH - ball.r) {
                    ball.x = WIDTH - ball.r;
                    ball.vx = -Math.abs(ball.vx);
                    triggerShake(3, 0.06);
                    sfxWall();
                }

                if (ball.y <= ball.r) {
                    ball.y = ball.r;
                    ball.vy = Math.abs(ball.vy);
                    triggerShake(3, 0.06);
                    sfxWall();
                }

                if (ball.y > HEIGHT + ball.r) {
                    loseLife();
                    return;
                }

                const p = state.paddle;
                if (
                    ball.y + ball.r >= p.y &&
                    ball.y - ball.r <= p.y + p.h &&
                    ball.x >= p.x &&
                    ball.x <= p.x + p.w &&
                    ball.vy > 0
                ) {
                    const hit = (ball.x - (p.x + p.w / 2)) / (p.w / 2);
                    const speed = Math.hypot(ball.vx, ball.vy) * 1.02;
                    ball.vx = hit * speed * 0.9;
                    ball.vy = -Math.abs(Math.sqrt(Math.max(12000, speed * speed - ball.vx * ball.vx)));
                    ball.y = p.y - ball.r - 0.1;
                    state.combo = 1;
                    state.comboTimer = 0;
                    sfxPaddle();
                }

                for (const brick of state.bricks) {
                    if (!brick.alive) continue;
                    if (
                        ball.x + ball.r < brick.x ||
                        ball.x - ball.r > brick.x + brick.w ||
                        ball.y + ball.r < brick.y ||
                        ball.y - ball.r > brick.y + brick.h
                    ) continue;

                    const cx = clamp(ball.x, brick.x, brick.x + brick.w);
                    const cy = clamp(ball.y, brick.y, brick.y + brick.h);
                    const dx = ball.x - cx;
                    const dy = ball.y - cy;
                    if (dx * dx + dy * dy > ball.r * ball.r) continue;

                    if (Math.abs(dx) > Math.abs(dy)) {
                        ball.vx *= -1;
                    } else {
                        ball.vy *= -1;
                    }

                    handleBrickHit(brick, ball);
                    break;
                }
            }

            ball.trail.unshift({ x: ball.x, y: ball.y });
            if (ball.trail.length > 9) ball.trail.pop();
        }

        function updatePaddle(dt) {
            let dir = 0;
            if (keys.left || mobileLeft) dir -= 1;
            if (keys.right || mobileRight) dir += 1;
            state.paddle.dx = dir * state.paddle.speed;
            state.paddle.x += state.paddle.dx * dt;
            state.paddle.x = clamp(state.paddle.x, 0, WIDTH - state.paddle.w);
        }

        function updateStars(dt) {
            state.stars.forEach((s) => {
                s.y += s.v * dt;
                if (s.y > HEIGHT) {
                    s.y = -2;
                    s.x = Math.random() * WIDTH;
                }
            });
        }

        function updateParticles(dt) {
            state.particles = state.particles.filter((p) => {
                p.life -= dt;
                if (p.life <= 0) return false;
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.vy += 380 * dt;
                p.vx *= 0.985;
                p.vy *= 0.985;
                return true;
            });
        }

        function update(dt) {
            if (audio.enabled && audio.ctx && audio.ctx.state === 'running' && state.running && !state.paused && !state.gameOver && !state.win && !audio.musicTimer) {
                startMusic();
            }
            if (!state.running || state.paused) {
                updateStars(dt);
                updateParticles(dt);
                return;
            }

            updateStars(dt);
            updatePaddle(dt);
            updateBall(dt);
            updateParticles(dt);

            if (state.comboTimer > 0) {
                state.comboTimer -= dt;
                if (state.comboTimer <= 0) {
                    state.combo = 1;
                }
            }

            state.shake.time = Math.max(0, state.shake.time - dt);
            state.flash.time = Math.max(0, state.flash.time - dt);
            updateHud();
        }

        function drawBackground(t) {
            const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
            g.addColorStop(0, '#0d1328');
            g.addColorStop(1, '#05070f');
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            ctx.globalAlpha = 0.85;
            for (const s of state.stars) {
                ctx.fillStyle = '#9ac0ff';
                ctx.fillRect(s.x, s.y, s.s, s.s);
            }
            ctx.globalAlpha = 1;

            ctx.strokeStyle = 'rgba(105, 219, 124, 0.08)';
            for (let y = 0; y < HEIGHT; y += 24) {
                const offset = Math.sin((t * 0.0015) + y * 0.05) * 8;
                ctx.beginPath();
                ctx.moveTo(offset, y);
                ctx.lineTo(WIDTH + offset, y);
                ctx.stroke();
            }
        }

        function drawBricks(t) {
            for (const brick of state.bricks) {
                if (!brick.alive) continue;
                const pulse = 0.86 + Math.sin((t * 0.006) + brick.x * 0.02) * 0.12;
                ctx.fillStyle = brick.color;
                ctx.globalAlpha = pulse;
                ctx.fillRect(brick.x, brick.y, brick.w, brick.h);
                ctx.globalAlpha = 1;
                if (brick.hp > 1) {
                    ctx.fillStyle = 'rgba(255,255,255,0.35)';
                    ctx.fillRect(brick.x + 6, brick.y + 7, brick.w - 12, 4);
                }
                ctx.strokeStyle = 'rgba(255,255,255,0.28)';
                ctx.strokeRect(brick.x + 0.5, brick.y + 0.5, brick.w - 1, brick.h - 1);
            }
        }

        function drawPaddle() {
            const p = state.paddle;
            const g = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.h);
            g.addColorStop(0, '#d0f4ff');
            g.addColorStop(1, '#4ea8de');
            ctx.fillStyle = g;
            ctx.fillRect(p.x, p.y, p.w, p.h);
            ctx.fillStyle = 'rgba(255,255,255,0.35)';
            ctx.fillRect(p.x + 8, p.y + 2, p.w - 16, 3);
        }

        function drawBall() {
            const ball = state.ball;
            for (let i = 0; i < ball.trail.length; i += 1) {
                const tr = ball.trail[i];
                ctx.globalAlpha = (1 - i / ball.trail.length) * 0.35;
                ctx.fillStyle = '#9be7ff';
                ctx.beginPath();
                ctx.arc(tr.x, tr.y, ball.r * (1 - i / ball.trail.length * 0.6), 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            const rg = ctx.createRadialGradient(ball.x - 2, ball.y - 3, 1, ball.x, ball.y, ball.r + 2);
            rg.addColorStop(0, '#ffffff');
            rg.addColorStop(0.35, '#a5f3ff');
            rg.addColorStop(1, '#38d9a9');
            ctx.fillStyle = rg;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawParticles() {
            for (const p of state.particles) {
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.size, p.size);
            }
            ctx.globalAlpha = 1;
        }

        function drawOverlay() {
            if (!state.gameOver && !state.win && state.running && !state.paused) return;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.42)';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            ctx.textAlign = 'center';

            if (state.gameOver) {
                ctx.fillStyle = '#ff6b6b';
                ctx.font = 'bold 58px Arial';
                ctx.fillText('GAME OVER', WIDTH / 2, HEIGHT / 2 - 24);
                ctx.fillStyle = '#ffffff';
                ctx.font = '22px Arial';
                ctx.fillText('按 R 或点击重开', WIDTH / 2, HEIGHT / 2 + 18);
                return;
            }

            if (state.win) {
                ctx.fillStyle = '#69db7c';
                ctx.font = 'bold 58px Arial';
                ctx.fillText('YOU WIN', WIDTH / 2, HEIGHT / 2 - 24);
                ctx.fillStyle = '#ffffff';
                ctx.font = '22px Arial';
                ctx.fillText('完美通关，按 R 再来一局', WIDTH / 2, HEIGHT / 2 + 18);
                return;
            }

            if (state.paused) {
                ctx.fillStyle = '#ffd43b';
                ctx.font = 'bold 52px Arial';
                ctx.fillText('PAUSED', WIDTH / 2, HEIGHT / 2 - 12);
                ctx.fillStyle = '#ffffff';
                ctx.font = '20px Arial';
                ctx.fillText('按 P 继续', WIDTH / 2, HEIGHT / 2 + 22);
                return;
            }

            if (!state.ball.launched) {
                ctx.fillStyle = '#63e6ff';
                ctx.font = 'bold 46px Arial';
                ctx.fillText('BREAKOUT', WIDTH / 2, HEIGHT / 2 - 30);
                ctx.fillStyle = '#ffffff';
                ctx.font = '22px Arial';
                ctx.fillText('按空格发球', WIDTH / 2, HEIGHT / 2 + 8);
                ctx.font = '16px Arial';
                ctx.fillText('方向键移动挡板，P 暂停，R 重开', WIDTH / 2, HEIGHT / 2 + 36);
            }
        }

        function render(t) {
            ctx.save();
            if (state.shake.time > 0) {
                const power = (state.shake.time / 0.25) * state.shake.strength;
                ctx.translate((Math.random() - 0.5) * power, (Math.random() - 0.5) * power);
            }

            drawBackground(t);
            drawBricks(t);
            drawPaddle();
            drawBall();
            drawParticles();

            if (state.flash.time > 0) {
                ctx.fillStyle = state.flash.color;
                ctx.globalAlpha = Math.min(0.26, state.flash.time * 0.8);
                ctx.fillRect(0, 0, WIDTH, HEIGHT);
                ctx.globalAlpha = 1;
            }

            drawOverlay();
            ctx.restore();
        }

        function gameLoop(ts) {
            if (!gameLoop.lastTs) gameLoop.lastTs = ts;
            const dt = Math.min(0.033, (ts - gameLoop.lastTs) / 1000);
            gameLoop.lastTs = ts;

            update(dt);
            render(ts);
            requestAnimationFrame(gameLoop);
        }

        function togglePause() {
            unlockAudio();
            if (!state.running || state.gameOver || state.win) return;
            state.paused = !state.paused;
            setStatus(state.paused ? '已暂停，按 P 继续' : '继续游戏');
            pauseBtn.textContent = state.paused ? '继续 (P)' : '暂停 (P)';
            if (state.paused) {
                stopMusic();
            } else {
                startMusic();
            }
            beep(state.paused ? 300 : 520, 0.05, 'sine', 0.05);
        }

        function restart() {
            unlockAudio();
            resetLevel(1, false);
            setStatus('按空格发球，左右方向键移动挡板');
            pauseBtn.textContent = '暂停 (P)';
            beep(480, 0.05, 'triangle', 0.06);
        }

        function onKeyDown(e) {
            unlockAudio();
            const key = e.key.toLowerCase();
            if (key === 'arrowleft' || key === 'a') {
                keys.left = true;
                e.preventDefault();
            }
            if (key === 'arrowright' || key === 'd') {
                keys.right = true;
                e.preventDefault();
            }
            if (key === ' ' || key === 'spacebar') {
                launchBall();
                e.preventDefault();
            }
            if (key === 'p') {
                togglePause();
                e.preventDefault();
            }
            if (key === 'r') {
                restart();
                e.preventDefault();
            }
        }

        function onKeyUp(e) {
            const key = e.key.toLowerCase();
            if (key === 'arrowleft' || key === 'a') keys.left = false;
            if (key === 'arrowright' || key === 'd') keys.right = false;
        }

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = ((e.clientX - rect.left) / rect.width) * WIDTH;
            state.paddle.x = clamp(x - state.paddle.w / 2, 0, WIDTH - state.paddle.w);
            if (!state.ball.launched) resetBall();
        });

        canvas.addEventListener('touchmove', (e) => {
            const touch = e.touches[0];
            if (!touch) return;
            const rect = canvas.getBoundingClientRect();
            const x = ((touch.clientX - rect.left) / rect.width) * WIDTH;
            state.paddle.x = clamp(x - state.paddle.w / 2, 0, WIDTH - state.paddle.w);
            if (!state.ball.launched) resetBall();
            e.preventDefault();
        }, { passive: false });

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);

        launchBtn.addEventListener('click', launchBall);
        pauseBtn.addEventListener('click', togglePause);
        restartBtn.addEventListener('click', restart);
        soundBtn.addEventListener('click', async () => {
            setSoundEnabled(!audio.enabled);
            if (audio.enabled) {
                await unlockAudio();
                beep(880, 0.07, 'triangle', 0.07);
            }
        });

        const leftBtn = document.getElementById('left-btn');
        const rightBtn = document.getElementById('right-btn');
        const launchMobileBtn = document.getElementById('launch-mobile-btn');

        function bindHoldButton(button, setter, value) {
            const onStart = (e) => { setter(value); e.preventDefault(); };
            const onEnd = (e) => { setter(false); e.preventDefault(); };
            button.addEventListener('pointerdown', onStart);
            button.addEventListener('pointerup', onEnd);
            button.addEventListener('pointerleave', onEnd);
            button.addEventListener('pointercancel', onEnd);
        }

        bindHoldButton(leftBtn, (v) => { mobileLeft = v; }, true);
        bindHoldButton(rightBtn, (v) => { mobileRight = v; }, true);
        launchMobileBtn.addEventListener('click', launchBall);

        resetLevel(1, false);
        setStatus('按空格发球，左右方向键移动挡板（若无声先点“声音: 开”）');
        soundBtn.textContent = '声音: 开';
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
