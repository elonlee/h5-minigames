<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classic Snake</title>
    <style>
        body {
            margin: 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #0b0b0b;
            color: #f2f2f2;
            font-family: Arial, sans-serif;
        }

        #game-container {
            width: 420px;
            max-width: calc(100vw - 24px);
            background: #121212;
            border: 3px solid #2a2a2a;
            padding: 12px;
            box-sizing: border-box;
        }

        #top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }

        #status {
            color: #bbbbbb;
            min-height: 18px;
            margin-bottom: 8px;
            font-size: 13px;
        }

        #game-canvas {
            width: 100%;
            aspect-ratio: 1;
            background: #000;
            border: 1px solid #303030;
            display: block;
        }

        #actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        button {
            background: #222;
            color: #fff;
            border: 1px solid #4a4a4a;
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
        }

        button:focus-visible {
            outline: 2px solid #7fb3ff;
            outline-offset: 2px;
        }

        #touch-controls {
            display: none;
            margin-top: 12px;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        #touch-controls .pad {
            min-height: 44px;
            font-size: 18px;
            font-weight: bold;
        }

        #up-btn { grid-column: 2; }
        #left-btn { grid-column: 1; grid-row: 2; }
        #down-btn { grid-column: 2; grid-row: 2; }
        #right-btn { grid-column: 3; grid-row: 2; }

        @media (max-width: 768px) {
            #touch-controls {
                display: grid;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="top-bar">
            <div>分数: <span id="score">0</span></div>
            <div>最高: <span id="high-score">0</span></div>
        </div>
        <div id="status">按方向键或 WASD 开始</div>
        <canvas id="game-canvas" width="400" height="400" aria-label="Snake 游戏画布"></canvas>
        <div id="actions">
            <button id="pause-btn" type="button">暂停 (P)</button>
            <button id="restart-btn" type="button">重新开始 (R)</button>
        </div>
        <div id="touch-controls" aria-label="触屏方向控制">
            <button id="up-btn" class="pad" type="button" aria-label="上">↑</button>
            <button id="left-btn" class="pad" type="button" aria-label="左">←</button>
            <button id="down-btn" class="pad" type="button" aria-label="下">↓</button>
            <button id="right-btn" class="pad" type="button" aria-label="右">→</button>
        </div>
    </div>

    <script>
        const GRID_SIZE = 20;
        const CANVAS_SIZE = 400;
        const CELL_SIZE = CANVAS_SIZE / GRID_SIZE;
        const TICK_MS = 130;
        const HIGH_SCORE_KEY = 'snakeHighScore';

        const DIRECTION_VECTORS = {
            up: { x: 0, y: -1 },
            down: { x: 0, y: 1 },
            left: { x: -1, y: 0 },
            right: { x: 1, y: 0 }
        };

        const OPPOSITE = {
            up: 'down',
            down: 'up',
            left: 'right',
            right: 'left'
        };

        function randomInt(max) {
            return Math.floor(Math.random() * max);
        }

        function createInitialState() {
            return {
                snake: [
                    { x: 10, y: 10 },
                    { x: 9, y: 10 },
                    { x: 8, y: 10 }
                ],
                direction: 'right',
                pendingDirection: 'right',
                food: { x: 15, y: 10 },
                score: 0,
                running: false,
                paused: false,
                gameOver: false,
                lastEvent: 'none',
                eventCell: null
            };
        }

        function equalCell(a, b) {
            return a.x === b.x && a.y === b.y;
        }

        function isOutOfBounds(cell) {
            return cell.x < 0 || cell.y < 0 || cell.x >= GRID_SIZE || cell.y >= GRID_SIZE;
        }

        function isSnakeCell(snake, cell) {
            return snake.some((segment) => equalCell(segment, cell));
        }

        function spawnFood(snake, rngInt) {
            const freeCells = [];
            for (let y = 0; y < GRID_SIZE; y += 1) {
                for (let x = 0; x < GRID_SIZE; x += 1) {
                    const cell = { x, y };
                    if (!isSnakeCell(snake, cell)) {
                        freeCells.push(cell);
                    }
                }
            }

            if (freeCells.length === 0) {
                return null;
            }

            return freeCells[rngInt(freeCells.length)];
        }

        function stepGame(currentState, rngInt) {
            const state = {
                ...currentState,
                snake: [...currentState.snake],
                lastEvent: 'none',
                eventCell: null
            };

            const nextDirection = state.pendingDirection;
            if (!(state.snake.length > 1 && OPPOSITE[state.direction] === nextDirection)) {
                state.direction = nextDirection;
            }

            const head = state.snake[0];
            const move = DIRECTION_VECTORS[state.direction];
            const nextHead = { x: head.x + move.x, y: head.y + move.y };

            if (isOutOfBounds(nextHead) || isSnakeCell(state.snake, nextHead)) {
                const eventName = isOutOfBounds(nextHead) ? 'wall-hit' : 'self-hit';
                return {
                    ...state,
                    running: false,
                    gameOver: true,
                    paused: false,
                    lastEvent: eventName,
                    eventCell: nextHead
                };
            }

            const nextSnake = [nextHead, ...state.snake];
            let nextFood = state.food;
            let nextScore = state.score;

            if (equalCell(nextHead, state.food)) {
                nextScore += 10;
                state.lastEvent = 'eat';
                state.eventCell = state.food;
                nextFood = spawnFood(nextSnake, rngInt);
            } else {
                nextSnake.pop();
            }

            if (!nextFood) {
                return {
                    ...state,
                    snake: nextSnake,
                    score: nextScore,
                    running: false,
                    gameOver: true,
                    paused: false,
                    lastEvent: 'win'
                };
            }

            return {
                ...state,
                snake: nextSnake,
                food: nextFood,
                score: nextScore
            };
        }

        window.SnakeCore = {
            createInitialState,
            spawnFood,
            stepGame,
            isOutOfBounds,
            isSnakeCell
        };

        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const highScoreEl = document.getElementById('high-score');
        const statusEl = document.getElementById('status');
        const pauseBtn = document.getElementById('pause-btn');
        const restartBtn = document.getElementById('restart-btn');

        let state = createInitialState();
        let timer = null;
        let highScore = Number(localStorage.getItem(HIGH_SCORE_KEY) || 0);
        let animationFrameId = null;
        const effects = {
            eat: null,
            wallHit: null,
            shatter: null
        };

        function nowMs() {
            return performance.now();
        }

        function hasActiveEffects(time) {
            return (
                (effects.eat && time < effects.eat.endAt) ||
                (effects.wallHit && time < effects.wallHit.endAt) ||
                (effects.shatter && time < effects.shatter.endAt)
            );
        }

        function getWallSide(cell) {
            if (!cell) return null;
            if (cell.x < 0) return 'left';
            if (cell.x >= GRID_SIZE) return 'right';
            if (cell.y < 0) return 'top';
            if (cell.y >= GRID_SIZE) return 'bottom';
            return null;
        }

        function ensureAnimationLoop() {
            if (animationFrameId !== null) {
                return;
            }
            const loop = () => {
                const time = nowMs();
                render();
                if (hasActiveEffects(time)) {
                    animationFrameId = requestAnimationFrame(loop);
                } else {
                    effects.eat = null;
                    effects.wallHit = null;
                    effects.shatter = null;
                    animationFrameId = null;
                }
            };
            animationFrameId = requestAnimationFrame(loop);
        }

        function randomRange(min, max) {
            return min + Math.random() * (max - min);
        }

        function createShatterParticles(snake, side) {
            const particles = [];
            snake.forEach((segment) => {
                const baseX = segment.x * CELL_SIZE + CELL_SIZE / 2;
                const baseY = segment.y * CELL_SIZE + CELL_SIZE / 2;
                const biasX = side === 'left' ? 1 : side === 'right' ? -1 : 0;
                const biasY = side === 'top' ? 1 : side === 'bottom' ? -1 : 0;
                for (let i = 0; i < 4; i += 1) {
                    particles.push({
                        x: baseX + randomRange(-3, 3),
                        y: baseY + randomRange(-3, 3),
                        vx: randomRange(-1.8, 1.8) + biasX * randomRange(1.2, 2.4),
                        vy: randomRange(-1.8, 1.8) + biasY * randomRange(1.2, 2.4),
                        size: randomRange(2, 4)
                    });
                }
            });
            return particles;
        }

        function playEffectsFromState(nextState) {
            const time = nowMs();
            let triggered = false;
            if (nextState.lastEvent === 'eat' && nextState.eventCell) {
                effects.eat = {
                    cell: nextState.eventCell,
                    startAt: time,
                    endAt: time + 220
                };
                triggered = true;
            }
            if (nextState.lastEvent === 'wall-hit') {
                const side = getWallSide(nextState.eventCell);
                effects.wallHit = {
                    side,
                    startAt: time,
                    endAt: time + 320
                };
                effects.shatter = {
                    particles: createShatterParticles(nextState.snake, side),
                    startAt: time,
                    endAt: time + 520
                };
                triggered = true;
            }
            if (triggered) {
                ensureAnimationLoop();
            }
        }

        function updateStatus() {
            if (state.gameOver) {
                statusEl.textContent = '游戏结束，按 R 或点击“重新开始”';
                return;
            }
            if (!state.running) {
                statusEl.textContent = '按方向键或 WASD 开始';
                return;
            }
            if (state.paused) {
                statusEl.textContent = '已暂停，按 P 继续';
                return;
            }
            statusEl.textContent = '进行中';
        }

        function updateScore() {
            scoreEl.textContent = String(state.score);
            highScoreEl.textContent = String(highScore);
        }

        function drawGrid() {
            ctx.strokeStyle = '#151515';
            ctx.lineWidth = 1;
            for (let i = 0; i <= GRID_SIZE; i += 1) {
                const p = i * CELL_SIZE;
                ctx.beginPath();
                ctx.moveTo(p, 0);
                ctx.lineTo(p, CANVAS_SIZE);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, p);
                ctx.lineTo(CANVAS_SIZE, p);
                ctx.stroke();
            }
        }

        function drawCell(cell, color) {
            ctx.fillStyle = color;
            ctx.fillRect(cell.x * CELL_SIZE + 1, cell.y * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
        }

        function render() {
            const time = nowMs();
            const wallEffect = effects.wallHit && time < effects.wallHit.endAt ? effects.wallHit : null;
            const eatEffect = effects.eat && time < effects.eat.endAt ? effects.eat : null;
            let shakeX = 0;
            let shakeY = 0;

            if (wallEffect) {
                const progress = (time - wallEffect.startAt) / (wallEffect.endAt - wallEffect.startAt);
                const strength = Math.max(0, 1 - progress) * 6;
                if (wallEffect.side === 'left' || wallEffect.side === 'right') {
                    shakeX = (Math.random() - 0.5) * strength;
                } else {
                    shakeY = (Math.random() - 0.5) * strength;
                }
            }

            ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            ctx.save();
            ctx.translate(shakeX, shakeY);
            drawGrid();
            drawCell(state.food, '#ff4d4f');
            state.snake.forEach((segment, index) => {
                drawCell(segment, index === 0 ? '#52c41a' : '#2f8f1c');
            });
            ctx.restore();

            if (eatEffect) {
                const progress = (time - eatEffect.startAt) / (eatEffect.endAt - eatEffect.startAt);
                const centerX = eatEffect.cell.x * CELL_SIZE + CELL_SIZE / 2;
                const centerY = eatEffect.cell.y * CELL_SIZE + CELL_SIZE / 2;
                const radius = CELL_SIZE * (0.2 + progress * 0.8);
                const alpha = Math.max(0, 0.8 - progress);
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(255, 215, 0, ${alpha})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            if (wallEffect) {
                const progress = (time - wallEffect.startAt) / (wallEffect.endAt - wallEffect.startAt);
                const alpha = Math.max(0, 0.35 - progress * 0.35);
                ctx.fillStyle = `rgba(255, 77, 79, ${alpha})`;
                ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            }

            const shatter = effects.shatter && time < effects.shatter.endAt ? effects.shatter : null;
            if (shatter) {
                const progress = (time - shatter.startAt) / (shatter.endAt - shatter.startAt);
                const alpha = Math.max(0, 0.95 - progress);
                shatter.particles.forEach((p) => {
                    const x = p.x + p.vx * progress * 18;
                    const y = p.y + p.vy * progress * 18 + progress * progress * 24;
                    ctx.fillStyle = `rgba(120, 255, 120, ${alpha})`;
                    ctx.fillRect(x, y, p.size, p.size);
                });
            }

            if (state.gameOver) {
                const overlayAlpha = shatter ? 0.22 : 0.45;
                ctx.fillStyle = `rgba(0, 0, 0, ${overlayAlpha})`;
                ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                ctx.fillStyle = '#ff4d4f';
                ctx.textAlign = 'center';
                ctx.font = 'bold 40px Arial';
                ctx.fillText('GAME OVER', CANVAS_SIZE / 2, CANVAS_SIZE / 2 - 4);
                ctx.fillStyle = '#ffffff';
                ctx.font = '16px Arial';
                ctx.fillText('按 R 重新开始', CANVAS_SIZE / 2, CANVAS_SIZE / 2 + 24);
            }

            updateScore();
            updateStatus();
            pauseBtn.textContent = state.paused ? '继续 (P)' : '暂停 (P)';
        }

        function stopTimer() {
            if (timer) {
                clearInterval(timer);
                timer = null;
            }
        }

        function startTimer() {
            stopTimer();
            timer = setInterval(() => {
                if (!state.running || state.paused || state.gameOver) {
                    return;
                }
                state = stepGame(state, randomInt);
                playEffectsFromState(state);
                if (state.score > highScore) {
                    highScore = state.score;
                    localStorage.setItem(HIGH_SCORE_KEY, String(highScore));
                }
                render();
                if (state.gameOver) {
                    stopTimer();
                }
            }, TICK_MS);
        }

        function restartGame() {
            state = createInitialState();
            effects.eat = null;
            effects.wallHit = null;
            effects.shatter = null;
            render();
            startTimer();
        }

        function queueDirection(nextDirection) {
            if (state.gameOver) {
                return;
            }
            if (!state.running) {
                state.running = true;
                state.paused = false;
                startTimer();
            }
            state.pendingDirection = nextDirection;
            render();
        }

        function togglePause() {
            if (!state.running || state.gameOver) {
                return;
            }
            state.paused = !state.paused;
            render();
        }

        function handleKeydown(event) {
            const key = event.key.toLowerCase();
            const map = {
                arrowup: 'up',
                w: 'up',
                arrowdown: 'down',
                s: 'down',
                arrowleft: 'left',
                a: 'left',
                arrowright: 'right',
                d: 'right'
            };

            if (key === 'p') {
                event.preventDefault();
                togglePause();
                return;
            }

            if (key === 'r') {
                event.preventDefault();
                restartGame();
                return;
            }

            const direction = map[key];
            if (direction) {
                event.preventDefault();
                queueDirection(direction);
            }
        }

        document.addEventListener('keydown', handleKeydown);
        pauseBtn.addEventListener('click', togglePause);
        restartBtn.addEventListener('click', restartGame);

        document.getElementById('up-btn').addEventListener('click', () => queueDirection('up'));
        document.getElementById('down-btn').addEventListener('click', () => queueDirection('down'));
        document.getElementById('left-btn').addEventListener('click', () => queueDirection('left'));
        document.getElementById('right-btn').addEventListener('click', () => queueDirection('right'));

        render();
    </script>
</body>
</html>
